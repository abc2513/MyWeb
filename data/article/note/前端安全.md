# 前端安全

## 常见攻击方式与防御

摘自：https://juejin.cn/post/6981348663298064397

摘自：https://juejin.cn/post/7067697624626757646

- 

### XSS 跨站脚本攻击

攻击者在`web`页面恶意插入`HTML`或`script`标签，当用户浏览该页面时，恶意代码就会被执行，从而达到攻击的目的。`XSS`利用的是**用户对指定网站的信任**。

类型：

- 反射型(非持久)：攻击者事先制作好攻击链接,需要欺骗用户自己去点击链接才能触发`XSS`代码，所谓反射型`XSS`就是将恶意用户输入的`js`脚本，反射到浏览器执行。
- 储存型(持久型)：会把攻击者的数据储存到服务端，攻击行为将伴随攻击数据一直存在，每当用户访问该页面就会触发代码执行。
- DOM型：基于文档对象模型的漏洞。 最经典的存储型`XSS`漏洞是留言板，当用户A在留言板留言一段`JS`代码`<script>alert("run javascript");</script>`,后端未经过滤直接存储到数据库，当正常用户浏览到他的留言后，这段`JS`代码就会被执行，可以借此来盗取`cookie`。

危害：

- 盗取网页浏览中的`cookie`值，盗用`cookie`实现无密码登录，盗取用户信息。
- 劫持访问，实现恶意跳转。
- 配合CSRF攻击完成恶意请求。

防御：

- 标签过滤，如`<script>`、`<img>`、`<a>`标签等
- 编码，对字符`<` 、`>`、`&`、`"` 、`'` 、`+`、`/`等进行转义。
- `cookie`防盗，将`cookie`设置为`http-only`,`js`脚本将无法读取到`cookie`信息。
- 纯前端渲染，明确`innerText`、`setAttribute`、`style`，将代码与数据分隔开。
- 避免不可信的数据拼接到字符串中传递给这些`API`，如`DOM`中的内联事件监听器，`location`、`onclick`、`onload`、`onmouseover`等，`<a>`标签的`href`属性，`JavaScript`的`eval()`、`setTimeout()`、`setInterval()`等，都能把字符串作为代码运行。

### CSRF 跨站点请求伪造

产生：

1. 用户`C`浏览并登录信任网站`A`,产生`cookie`
2. 用户`C`未退出网站`A`，在同一个浏览器危险访问网站`B`
3. 网站`B`的页面存有一些攻击性的代码，会发出访问`A`的请求
4. 浏览器收到请求后，在用户不知情的情况下携带`cookie`访问网站`A``
5. `A`不知道请求是谁发的，浏览器会带上用户的`cookie`，所以`A`会根据用户的权限处理`B`发出的请求。这样就达到了攻击的目的。

防御：

- 验证码：对敏感操作加入验证码，强制用户与网站进行交互
- 对`Cookie`设置`SameSite`属性。该属性表示`Cookie`不随着跨域请求发送，可以很大程度减少`CSRF`的攻击，但是该属性目前并不是所有浏览器都兼容。
- 使用`POST`请求，避免使用`GET`，降低攻击风险，`post`请求攻击方需要构造一个`form`表单才可以发起请求，比`get`请求（`img`的`src`，`a`标签的`href`等等）的攻击方式复杂了一些，相对来说能降低风险，但不能阻止。
- 检查`HTTP`中的`referer`字段，该字段记录了`HTTP`请求的来源地址
- 在请求头中加入`token`验证字段，浏览器并不会自动携带`Token`去请求，且`Token`可以携带一段加密的`jwt`用作身份认证，这样进行`CSRF`的时候仅传递了`cookie`，并不能表明用户身份，网站即拒绝攻击请求。
- 在`http`中自定义属性并验证。

### Cookie挟持

`HTTP`是无状态的协议，为了维持和跟踪用户的状态，引入了`Cookie`和`Session`。 `Cookie`包含了浏览器客户端的用户凭证，相对较小。`Session`则维护在服务器，用于维护相对较大的用户信息。可以把`Cookie`当成密码，而`Session`是保险柜。由于`HTTP`是明文传输，`Cookie`很容易被盗取，如果被盗取，别人就可以冒充你的身份，打开你的保险柜，获取你的信息，动用你的资金，这是很危险的。

危害

- 给`cookie`添加`HttpOnly`属性，该属性设置后，只能在`http`请求中传递，在脚本中，`document.cookie`无法获取到该`cookie`值，对XSS攻击有防御作用，但对网络拦截还是会泄露。
- 在`cookie`中添加校验信息，这个校验信息和当前用户外置环境有些关系，比如`ip`、`user agent`等有关.这样当`cookie`被人劫持冒用时，在服务器端校验的时候，发现校验值发生了变化，因此会要求用户重新登录，可以规避`cookie`劫持。
- `cookie`中`session id`的定时更换，让`session id`按一定频率变换，同时对用户而言，该操作是透明的，这样保证了服务体验的一致性。



### 点击劫持

> 点击劫持（Clickjacking）是一种通过视觉欺骗的手段来达到攻击目的手段。往往是攻击者将目标网站通过 iframe 嵌入到自己的网页中，通过 opacity 等手段设置 iframe 为透明的，使得肉眼不可见，这样一来当用户在攻击者的网站中操作的时候，比如点击某个按钮（这个按钮的顶层其实是 iframe），从而实现目标网站被点击劫持。

防御：

- 在HTTP投中加入 `X-FRAME-OPTIONS` 属性，此属性控制页面是否可被嵌入 iframe 中
  - DENY：不能被所有网站嵌套或加载；
  - SAMEORIGIN：只能被同域网站嵌套或加载；
  - ALLOW-FROM URL：可以被指定网站嵌套或加载。
- 判断当前网页是否被 iframe 嵌套

### CDN劫持

> CDN：它的名字就叫做`CDN`——**Content Delivery Network**，内容分发网络。具体来说，`CDN`就是采用更多的缓存服务器（CDN边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。（有点像电商的本地仓吧？）CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。

> CDN劫持：网络上有很多黑客为了让用户能够登录自己开发的钓鱼网站，都会通过对CDN进行劫持的方法，让用户自动转入自己开发的网站。而很多用户却往往无法察觉到自己已经被劫持。其实验证被劫持的方法，就是输入任何网址看看所打开的网页是否和自己输入的网址一致，

防御：SRI

> **SRI** 全称 Subresource Integrity - 子资源完整性，是指浏览器通过验证资源的完整性（通常从 CDN 获取）来判断其是否被篡改的安全特性。

通过给 link 标签或者 script 标签增加 integrity 属性即可开启 SRI 功能，比如

```html
<script type="text/javascript" src="//s.url.cn/xxxx/aaa.js" 
        integrity="sha256-xxx sha384-yyy"
        crossorigin="anonymous"></script>
```

integrity 值分成两个部分，第一部分指定哈希值的生成算法（sha256、sha384 及 sha512），第二部分是经过  base64 编码的实际哈希值，两者之间通过一个短横（-）分割。integrity  值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。**开启 SRI 能有效保证页面引用资源的完整性，避免恶意代码执行。**

### SQL注入

没有做数据校验、转码，导致数据被当作代码执行

栗子：

```sql
SELECT * FROM user WHERE username='admin' --' AND psw='xxxx'
```

步骤

- 获取用户请求参数
- 拼接到代码当中
- SQL语句按照我们构造参数的语义执行成功

SQL注入的必备条件：
 1.可以控制输入的数据
 2.服务器要执行的代码拼接了控制的数据



危害：

- 获取数据库信息
  - 管理员后台用户名和密码
  - 获取其他数据库敏感信息：用户名、密码、手机号码、身份证、银行卡信息……
  - 整个数据库：脱裤
- 获取服务器权限
- 植入Webshell，获取服务器后门
- 读取服务器敏感文件

防御：

**严格限制Web应用的数据库的操作权限**，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害

**后端代码检查输入的数据是否符合预期**，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。

**对进入数据库的特殊字符（'，"，，<，>，&，\*，; 等）进行转义处理，或编码转换**。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。

**所有的查询语句建议使用数据库提供的参数化查询接口**，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。

### OS注入

用户提交一些内容到服务器，然后在服务器执行一些系统命令去返回一个结果给用户

黑客构造命令提交给web应用程序，web应用程序提取黑客构造的命令，拼接到被执行的命令中，因黑客注入的命令打破了原有命令结构，导致web应用执行了额外的命令

防御：

- 后端对前端提交内容进行规则限制（比如正则表达式）。
- 在调用系统命令前对所有传入参数进行命令行参数转义过滤。
- 不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 `shell-escape npm`包
- web服务器不要开root权限

## 提升安全性

https://developer.mozilla.org/zh-CN/docs/Web/Security#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8

- 内容安全
- 连接安全
- 信息泄漏
- 完整性
- 用户信息安全

### CSP内容安全策略

> 防XSS等攻击的利器。CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。

### CSP的分类

- `Content-Security-Policy` 配置好并启用后，不符合 CSP 的外部资源就会被阻止加载。
- `Content-Security-Policy-Report-Only` 表示不执行限制选项，只是记录违反限制的行为。它必须与`report-uri`选项配合使用。

### CSP的使用

- 通过 HTTP 头配置` Content-Security-Policy`，以下配置说明该页面只允许当前源和` https://apis.google.com` 这 2 个源的脚本加载和执行：

```http
Content-Security-Policy: script-src 'self' https://apis.google.com
```

- 通过页面 `<meta>` 标签配置：

```html

<meta http-equiv="Content-Security-Policy" content="script-src 'self' https://apis.google.com">
```

