# Web性能优化

## 引用

教程视频：

转载视频：https://www.youtube.com/playlist?list=PLAwxTw4SYaPmKmNX-INgcxQWf30KuWa_A   https://www.bilibili.com/video/BV1V84y1F7py



稀土博客：https://juejin.cn/post/7029973323475845150

## 思路

1. 性能指标和衡量
2. 生命周期
3. 优化方案
   1. 网络传输角度
   2. 浏览器角度
   3. 资源、图片角度
   4. 代码层面
   5. 打包工具角度

## 性能指标与测量

- 性能指标
  - FCP
  - LCP
  - FID
  - TTI
  - TBT
  - CLS
- 测量工具
  - 灯塔

## 优化方案

#### 缩短关键呈现路径（生命周期看优化）

1. 请求html文档（阻塞）
   1. 移除html注释、压缩、缓存
1. 解析html、构建DOM（逐步）
1. 请求发现的CSS、JS等资源
   1. 移除注释、压缩、缓存
   1. link内使用媒体查询
   1. 使用内联
1. 解析CSS构建CSSOM（阻塞JS）
   1. 
1. 执行JS（阻塞DOM）
   1. onload后执行
   1. 添加async属性
1. 合并DOM和CSSOM成渲染树
1. 计算布局和绘制页面
   1. 减少/合并操作DOM和CSSOM（批量更新）
   1. 使用css动画：在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。

#### 优化网络请求

- DNS解析：DNS预获取、减少域名数量、缓存DNS
- gzip压缩
- cdn加速，静态资源做cdn缓存
- 浏览器缓存：设置浏览器缓存策略
- 减少请求次数和体积：压缩文件、合并小文件
- 使用http2
- 加载时间内做动画（优化体验）

#### 优化资源管理

`静态资源cdn`
 静态css/js/img等资源可以做cdn缓存，这样把资源同步到全国全球各地，用户就能更快访问到

```
静态资源单独域名
```

1. 浏览器请求并发限制（同一域名（包括二级域名）在同一时间支持的并发请求数量的限制）
2. cookie传输，单独域名，不会携带cookie
3. 方便分流和缓存（动静分离，有利于静态资源做cdn缓存）

`gzip压缩`
 使资源体积更小
 服务端配置，如nginx可配置支持gzip压缩资源传输的方式
 如果浏览器支持gzip解析，服务器就会推送gzip的资源，在http的相应头里可以看到显示Content-Encoding:gzip

`做服务端渲染（SSR）`
 现在主流框的react、vue导致的一个痛点，就是页面构建交给了客户端来渲染，构建的过程无疑是排在了请求到html/js资源后，也就是至少两次http请求后才开始构建，这无疑是导致白屏的关键点之一，所以做ssr页面的话，能够直接返回页面，减少了不少首屏渲染时间

`将CSS放在文件头部，JavaScript文件放在底部`
 单线程js可能会阻滞文档加载

#### 优化图片相关

- 图片压缩
- 使用png格式
- 小图片使用base64
- 图片懒加载
- 精灵图
- 使用字体图标代替图片
- svg代替二进制像素图

#### JS的优化

```
慎用全局变量
```

1. 全局变量定义在全局执行上下文，是所有作用域链的顶端。局部找不到就会一直往上找，影响性能
2. 全局执行上下文一直存在于上下文执行栈，直到程序退出，不利于GC回收
3. 命名污染

`缓存全局变量`
 将使用中无法避免的全局变量缓存到局部

`减少重绘回流`
 回流：当元素的规模尺寸，布局，隐藏等改变的时候，render dom需要重新构建，这就称为回流
 重绘：元素只更新外观，风格，而不会影响布局的，叫重绘

```
节流、防抖
少用闭包、减少内存泄漏
```

`减少数据读取次数`
 如for循环优化，减少length读取次数

```

```

`文档碎片优化节点添加`
 dom：document.createDocumentFragment()

`减少判断层级`
 减少if else，提前return if不满足的逻辑

`字面量与构造式`
 数组、对象、字符串等，直接声明比new 更快

#### 打包工具的优化

- `减小代码体积`
- `按需加载`
- `提取第三库代码`
- `webpack dll优化`

#### 其他

`web worker`
 web worker是运行在后台的js，独立于其他脚本，不会影响页面你的性能。并且通过postMessage将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。

`避免 ifarme 嵌套网页`
 阻止了onload，使用户感觉加载很慢的感觉
 与父页面共享浏览器连接池，与父页面并行占用http最大连接数，所以资源加载更慢
 不利于seo
 兼容性不太好，如小程序里面嵌入h5，h5又使用了ifarme